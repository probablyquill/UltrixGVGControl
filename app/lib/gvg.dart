import "dart:io";
import "dart:async";

const _soh = "01 ";
const _protocol = "4E 30 ";
const _eol = "04";
const _tab = "09 ";

/*
To pass a number to the Ultrix router over the GVG protocol, a handful of 
conversions need to take place.
  1.) Decimal -> Hex e.x.: 15 -> 0x0F
  2.) Hex to 4 char ASCII string e.x. 0x0F -> 000F
  3.) ASCII string to hex e.x. 000F -> 30 30 30 46
*/
String _gvgConvertNumber(int number) {
  String hexString = number.toRadixString(16);
  String outputString = "";

  while (hexString.length < 4) {
    hexString = "0$hexString";
  }

  hexString = hexString.toUpperCase();

  for (int i = 0; i < hexString.length; i++) {
    outputString += "${hexString.codeUnitAt(i).toRadixString(16)} ";
  }

  return outputString;
}

int gvgDeconvertNumber(String input) {
  int output = int.parse("0x$input");
  return output;
}
/*
The checksum is generated by following these steps:
  1.) Sum every hex value given
  2.) Bitwise and to ensure it is not larger than 8 bits.
  3.) Find the 2s compliment
  4.) Perform the gvg number conversion and remove the leading 0x30s.
*/
String _gvgChecksum(String preChecksum) {
  List<String> byteList = preChecksum.split(" ");
  int total = 0;

  // byteList - 1 is used because the given String will have a trailing space.
  for (int i = 0; i < byteList.length - 1; i++) {
      String temp = byteList[i];
      total += gvgDeconvertNumber(temp);
  }
  
  total = total & 0xFF;
  total = (0x100 - total) & 0xFF;

  String checksum = _gvgConvertNumber(total).substring(6);
  return checksum;
}

// EXAMPLE RESPONSE:      CROSSPOINT IN HEX (convert to decimal 81 -> 129; 129 + 1 = 130)
// N0JQ\t0063\t3\tN\tN\t 0081        \t000001F9\tP\tN\t0058\t00000006\tN\tN\t0000\t0001FE00\t39
String queryDestinationStatus(int destination) {
  String qds = "51 4A ";

  destination = destination - 1;
  if (destination < 0) destination = 0;

  String destHex = _gvgConvertNumber(destination);

  String command = "$_protocol$qds$_tab$destHex";
  String checksum = _gvgChecksum(command);

  command = "$_soh$command$checksum$_eol";
  return command;
}

String take(int destination, int source) {
  String take = "54 49 ";
  
  // GVG Protocol counts from zero.
  destination = destination - 1;
  source = source - 1;

  String destHex = _gvgConvertNumber(destination);
  String sourceHex = _gvgConvertNumber(source);

  String takeCommand = "$_protocol$take$_tab$destHex$_tab$sourceHex";
  String checksum = _gvgChecksum(takeCommand);
  takeCommand = "$_soh$takeCommand$checksum$_eol";
  return takeCommand;
}

// These can be hardcoded but I will want to keep the code that generates them somewhere. 
String queryDestination() {
  String command = "51 4E 09 44 ";
  command = "$_protocol$command";

  String checksum = _gvgChecksum(command);
  command = "$_soh$command$checksum$_eol";
  return command;
}

String querySource() {
  String command = "51 4E 09 53 ";
  command = "$_protocol$command";

  String checksum = _gvgChecksum(command);
  command = "$_soh$command$checksum$_eol";
  return command;
}

Future<List<String>> sendCommand(String ipaddr, int port, String message) async {
  Socket socket;
  List<int> bytes = [];
  Completer<List<String>> output = Completer<List<String>>();
  String dataResponse = "";

  // Converts command string to bytes to send over a socket.
  message = message.replaceAll(" ", "");
  for (int i = 0; i < message.length; i+=2) {
    bytes.add(int.parse("0x${message[i]}${message[i + 1]}"));
  }

  try { //Catches Socket timeout exception -> potentially should be moved
    socket = await Socket.connect(ipaddr, port, timeout: Duration(seconds: 3));
    socket.add(bytes);
    socket.listen(
      (data) {
        // If the command sent was a take command, the server will respond with only bytes.
        // Clean up and compile responses.
        String response = String.fromCharCodes(data).trim();
        dataResponse += response;
        // Final packet ends with FFFFFFFF63 in the long responses (list of dest and list of source)
        if (response.contains("FFFFFFFF63")) socket.close();
        // Different commands will lead with different identifiers, which can be used to identify single-packet
        // responses.
        String header = response.substring(0, 5);
        if (header.contains("N0JQ")) socket.close();
        if (header.contains("N0ER")) socket.close();
      },
      onDone: () {
        output.complete(_dataCleaner(dataResponse));
        socket.destroy();
        },
      onError: (error) {
        print('Error: $error');
        socket.destroy();
      }
    );
  } on SocketException { //For now, empty list will translate as connection error. Command error should still return data.
    output.complete([]);
  }

  return output.future;
}

List<String> _dataCleaner(response) {
  //Data is split with tabs: breaking it into an array like this breaks everything up nicely.
  List<String> dataToParse = response.split("\t");
  List<String> cleanArray = [];

  // Clean data.
  for (int i = 0; i < dataToParse.length; i++) {
    String value = dataToParse[i];

    // This is fine for stripping the excess data and empty spaces for now, but that data probably means something.
    if (value.length <= 1) continue;
    if (value.contains("FFFFFF")) continue;
    cleanArray.add(value.trim());
  }
  // Temporary trim to 144 + 1 for testing (includes leading identifier). 
  // Cuts out MV and MADI name that are on the end of source/dest responses.
  // Single packet responses will not get anywhere near the threshold and will be untouched.
  for (int i = cleanArray.length - 1; i >= 145; i--) {
    cleanArray.removeAt(i);
  }
  return cleanArray;
}