import "dart:io";

const _soh = "01 ";
const _protocol = "4E 30 ";
const _eol = "04";
const _tab = "09 ";

/*
To pass a number to the Ultrix router over the GVG protocol, a handful of 
conversions need to take place.
  1.) Decimal -> Hex e.x.: 15 -> 0x0F
  2.) Hex to 4 char ASCII string e.x. 0x0F -> 000F
  3.) ASCII string to hex e.x. 000F -> 30 30 30 46
*/
String _gvgConvertNumber(int number) {
  String hexString = number.toRadixString(16);
  String outputString = "";

  while (hexString.length < 4) {
    hexString = "0$hexString";
  }

  hexString = hexString.toUpperCase();

  for (int i = 0; i < hexString.length; i++) {
    outputString += "${hexString.codeUnitAt(i).toRadixString(16)} ";
  }

  return outputString;
}

int _gvgDeconvertNumber(String input) {
  int output = int.parse("0x$input");
  return output;
}
/*
The checksum is generated by following these steps:
  1.) Sum every hex value given
  2.) Bitwise and to ensure it is not larger than 8 bits.
  3.) Find the 2s compliment
  4.) Perform the gvg number conversion and remove the leading 0x30s.
*/
String _gvgChecksum(String preChecksum) {
  List<String> byteList = preChecksum.split(" ");
  int total = 0;

  // byteList - 1 is used because the given String will have a trailing space.
  for (int i = 0; i < byteList.length - 1; i++) {
      String temp = byteList[i];
      total += _gvgDeconvertNumber(temp);
  }
  
  total = total & 0xFF;
  total = (0x100 - total) & 0xFF;

  String checksum = _gvgConvertNumber(total).substring(6);
  return checksum;
}

// EXAMPLE RESPONSE:      CROSSPOINT IN HEX (convert to decimal 81 -> 129; 129 + 1 = 130)
// N0JQ\t0063\t3\tN\tN\t 0081        \t000001F9\tP\tN\t0058\t00000006\tN\tN\t0000\t0001FE00\t39
String _queryDestinationStatus(int destination) {
  String qds = "51 4A ";

  destination = destination - 1;
  if (destination < 0) destination = 0;

  String destHex = _gvgConvertNumber(destination);

  String command = "$_protocol$qds$_tab$destHex";
  String checksum = _gvgChecksum(command);

  command = "$_soh$command$checksum$_eol";
  return command;
}

String _take(int destination, int source) {
  String take = "54 49 ";
  
  // GVG Protocol counts from zero.
  destination = destination - 1;
  source = source - 1;

  String destHex = _gvgConvertNumber(destination);
  String sourceHex = _gvgConvertNumber(source);

  String takeCommand = "$_protocol$take$_tab$destHex$sourceHex";
  String checksum = _gvgChecksum(takeCommand);
  takeCommand = "$_soh$takeCommand$checksum$_eol";
  return takeCommand;
}

String _queryDestination() {
  String command = "51 4E 09 44 ";
  command = "$_protocol$command";

  String checksum = _gvgChecksum(command);
  command = "$_soh$command$checksum$_eol";
  return command;
}

String _querySource() {
  String command = "51 4E 09 53 ";
  command = "$_protocol$command";

  String checksum = _gvgChecksum(command);
  command = "$_soh$command$checksum$_eol";
  return command;
}

void _sendCommand(String ipaddr, int port, String message) async {
  Socket socket;
  List<int> bytes = [];
  String dataResponse = "";

  // Converts command string to bytes to send over a socket.
  message = message.replaceAll(" ", "");
  for (int i = 0; i < message.length; i+=2) {
    bytes.add(int.parse("0x${message[i]}${message[i + 1]}"));
  }

  socket = await Socket.connect(ipaddr, port);
  socket.add(bytes);
  socket.listen(
    (data) {
      // Clean up and compile responses.
      String response = String.fromCharCodes(data).trim();
      dataResponse += response;
      // Final packet ends with FFFFFFFF63 in the long responses (list of dest and list of source)
      if (response.contains("FFFFFFFF63")) socket.close();
      // Different commands will lead with different identifiers, which can be used to identify single-packet
      // responses.
      if (response.substring(0, 5).contains("N0JQ")) socket.close();
    },
    onDone: () {
      List<String> responses = _dataCleaner(dataResponse);
      print(responses);
      socket.destroy();
      },
    onError: (error) {
      print('Error: $error');
      socket.destroy();
    }
  );
}

List<String> _dataCleaner(response) {
  //Data is split with tabs: breaking it into an array like this breaks everything up nicely.
  List<String> dataParse = response.split("\t");
  List<String> cleanArray = [];

  // Clean data. i starts at 1 because we are skiping an identifier value.
  for (int i = 1; i < dataParse.length; i++) {
    bool addFlag = true;
    String value = dataParse[i];

    // This is fine for stripping the excess data for now, but that data probably means something.
    if (value.length == 1) addFlag = false;
    // Removes header for source/dest name packet group.
    if (value.contains("FFFFFF")) addFlag = false;
    if (addFlag) cleanArray.add(value.trim());
  }
  // Temporary trim to 144 for testing. Cuts out MV and MADI name that are on the end of source/dest responses.
  // Single packet responses will not get anywhere near the threshold and will be untouched.
  for (int i = cleanArray.length - 1; i >= 144; i--) {
    cleanArray.removeAt(i);
  }
  return cleanArray;
}

void main() {
  String message = _queryDestination();

  _sendCommand("192.168.0.100", 12345, message);
}